// Створити пустий об’єкт;

let emptyObj={};

// Створити пустий об’єкт без прототипу;

let noProto = Object.create(null);

// Додати до об’єкта будь які нові поля всіма відомими способами;

let car = {};
car.age = 10;
car["brand and model"] = "BMW M5";

// Створити пустий масив;

let emptyArr = [];

// Створити пустий масив довжиною 100500 елементів;

let arr100500 = new Array(100500);

// Створити масив з декількома елементами;

let someArr =[1,2,3,4];

// Зробити заповнений масив пустим;

let filledArr = [1,2,3,4,5];
filledArr = [];

// Дано масив, [1,2,3,4,5], потрібно створити функцію, яка видалить певний елемент з масиву за його індексом та поверне новий масив(оновлений- після видалення);

function deleteByIndex(index,arr) {
    arr.splice(index,1);
    return arr;
};

// Створити функцію, яка приймає один масив у якості аргументу та повертає булеве значення в залежності чи в неї передали пустий масив чи ні;

function isEmptyArr(arr){
    return arr.length==true;
};

//функція працює з точністю до навпаки. Якщо вона називається isEmptyArray - вона має повертати true якщо масив пустий
//Ще порада - замість перевірки "value === true" можна використовувати конструкцію "!!value"

// Створити функцію, яка приймає один об’єкт у якості аргументу та повертає булеве значення в залежності чи в неї передали пустий об’єкт чи ні;

function isEmptyObj(obj){
    return Object.keys(obj).length==true;
};

//те саме, що і з попереднім

// Створити функцію, яка обєднає два масиви в один та поверне його в якості результату;

function arrConcat(arr1,arr2){
    return arr3 = arr1.concat(arr2);
};
// Створити функцію, яка приймає один масив чисел у якості аргументу та повертає новий масив, який складається з елементів попереднього в степені 3. Для прикладу, на вході: [1, 2, 3] ⇒ [1, 8, 27];

/* function cube(arr){
     let arr2 = [];
    for(let i of arr){
      arr2.push(i**3);
    }
    return arr2;
    
}; */

function cube(arr){
    for(let i in arr){
      arr.splice(i,1,arr[i]**3);
    };
   return arr;
};

//перший спосіб в рази ліпший, ніж другий. Другий якось дуже дивно і неочевидно працює.
//Ліпше тоді писати arr[i] = arr[i]**3
//А ще ліпше - перетворювати масив за допомогою методу .map

// Створити функцію, яка приймає один масив чисел у якості аргументу та повертає новий масив, який складається з непарних елементів вхідного масиву;

function filterOdd(arr){
    let filteredArr=[]
    for(let i in arr){
        if(arr[i] %2 !==0)  {
              arr1.push(arr[i])
      };      
    };
    return filteredArr;
};
    
// Функція не працює, нема такої змінної як arr1. Мало б бути filteredArr.push(), будь уважніший

// Створити функцію, яка приймає один масив чисел у якості аргументу та повертає новий масив, який складається тільки з цілих елементів вхідного масиву; Для прикладу: [5, 3.14, 4.1, 10, 11, 20.1] ⇒ [5, 10, 11];

function filterInteger(arr){
    let filteredArr=[]
    for(let i in arr){
        if(arr[i] % 1 === 0)  {
              arr1.push(arr[i])        
      };      
    };
    return filteredArr;     
};

//те саме
    

// Створити функцію, яка нічого не повертає;

function returnUndefined(){}